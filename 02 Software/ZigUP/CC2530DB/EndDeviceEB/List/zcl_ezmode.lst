###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               20/Nov/2021  20:16:45
# Copyright 2004-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\Z-Stack Home 1.2.2a.44539\Components\stack\zcl\zcl_ezmode.c
#    Command line       =  
#        -f C:\Users\tatbo\AppData\Local\Temp\EWCEDE.tmp ("D:\Z-Stack Home
#        1.2.2a.44539\Components\stack\zcl\zcl_ezmode.c" -D SECURE=1 -D
#        HAL_KEY=FALSE -D HAL_LED=FALSE -D HAL_LCD=FALSE -D HAL_UART=FALSE -D
#        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xHOLD_AUTO_START -D
#        ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=FALSE -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_WRITE -D ZCL_REPORT -D xZCL_EZMODE -D ZCL_BASIC -D ZCL_IDENTIFY -D
#        ZCL_ON_OFF -D ZCL_SCENES -D ZCL_GROUPS -D xZCL_LEVEL_CTRL -D
#        ZCL_DIAGNOSTIC -D FEATURE_SYSTEM_STATS -D ZCL_DOORLOCK -lC "D:\Z-Stack
#        Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\EndDeviceEB\List"
#        -lA "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\" -I
#        "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\Source\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\Source\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_China.936
#    List file          =  
#        D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\EndDeviceEB\List\zcl_ezmode.lst
#    Object file        =  
#        D:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\ZigUP\CC2530DB\EndDeviceEB\Obj\zcl_ezmode.r51
#
###############################################################################

D:\Z-Stack Home 1.2.2a.44539\Components\stack\zcl\zcl_ezmode.c
      1          /**************************************************************************************************
      2            Filename:       zcl_ezmode.c
      3            Revised:        $Date: 2014-12-03 14:48:39 -0800 (Wed, 03 Dec 2014) $
      4            Revision:       $Revision: 41325 $
      5          
      6            Description:    Zigbee Cluster Library - EZ Mode
      7          
      8          
      9            Copyright 2013-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          
     45          #include "zcl.h"
     46          #include "zcl_general.h"
     47          #include "zcl_ezmode.h"
     48          
     49          #if !defined ( ZCL_STANDALONE )
     50            #include "OSAL.h"
     51            #include "zcl_ha.h"
     52          #endif
     53          
     54          
     55          #ifdef ZCL_EZMODE
     56          
     57          /*********************************************************************
     58           * MACROS
     59           */
     60          
     61          /*********************************************************************
     62           * CONSTANTS
     63           */
     64          
     65          /*********************************************************************
     66           * TYPEDEFS
     67           */
     68          
     69          /*********************************************************************
     70           * LOCAL PROTOTYPES
     71           */
     72          static void zcl_SetEZModeError( uint8 errorCode );
     73          static void zcl_SetEZModeState( zlcEZMode_State_t newState );
     74          static void zcl_ProcessEZMode( void );
     75          
     76          
     77          /*********************************************************************
     78           * GLOBAL VARIABLES
     79           */
     80          
     81          // internal EZ-Mode state machine
     82          uint8  zclEZModeRegistered;
     83          uint8  zclEZModeErr;
     84          uint8  zclEZModeState;
     85          uint8  zclEZModeOpener;
     86          uint8  zclEZModeMatched;              // we were matched by a remote node
     87          uint16 zclEZModeQueryRspNwkAddr;      // short address (on QueryRsp)
     88          uint8  zclEZModeQueryRspEP;           // endpoint (on QueryRsp)
     89          zclEZMode_RegisterData_t zclEZModeRegisterData; // registered once on init
     90          zclEZMode_InvokeData_t   zclEZModeInvokeData; // user's configuration parameters
     91                                                        // what endpoint, initiator, etc.
     92          
     93          /*********************************************************************
     94           * GLOBAL FUNCTIONS
     95           */
     96          
     97          /*********************************************************************
     98           * @fn      zcl_RegisterEZMode
     99           *
    100           * @brief   Called upon task initialation, to initialize EZ-Mode.
    101           *
    102           * @param   pData - task ID, App Callback routine, etc..
    103           *
    104           * @return  none
    105           */
    106          void zcl_RegisterEZMode( zclEZMode_RegisterData_t const *pData )
    107          {
    108            // make a copy of the data. Cannot fail.
    109            zcl_memcpy( &zclEZModeRegisterData, (void *)pData,
    110                        sizeof(zclEZMode_RegisterData_t) );
    111            zclEZModeRegistered = TRUE;
    112          }
    113          
    114          /*********************************************************************
    115           * @fn      zcl_InvokeEZMode
    116           *
    117           * @brief   Called to invoke EZ-Mode on an endpoint. This is a toggle
    118           *          (will cancel if EZ-Mode currently enabled). Note: there is only 1
    119           *          state machine. EZ-Mode can only be invoked on 1 endpoint at a time.
    120           *
    121           * @param   none
    122           *
    123           * @return  none
    124           */
    125          void zcl_InvokeEZMode( zclEZMode_InvokeData_t *pData )
    126          {
    127            // if not registered, do nothing
    128            if(!zclEZModeRegistered)
    129            {
    130              return;
    131            }
    132          
    133            // there is only 1 EZ-Mode state machine. If already in EZ-Mode, cancel it
    134            if(zclEZModeState != EZMODE_STATE_READY)
    135            {
    136              zcl_SetEZModeError ( EZMODE_ERR_CANCELLED );
    137              // needed to shut down timers, turn off joining, etc...
    138              zcl_SetEZModeState ( EZMODE_STATE_FINISH );
    139              return;
    140            }
    141          
    142            // copy the data, so we remember which endpoint, etc...
    143            zcl_memcpy( &zclEZModeInvokeData, pData, sizeof(zclEZMode_InvokeData_t) );
    144          
    145            // start with no error, and no QueryResponses in our list
    146            zcl_SetEZModeError ( EZMODE_ERR_SUCCESS );
    147            zclEZModeOpener = zclEZModeMatched = 0;
    148          
    149            // if already on network, just go to identify state
    150            if ( zclEZModeInvokeData.onNetwork )
    151            {
    152              zcl_SetEZModeState( EZMODE_STATE_OPENER );
    153            }
    154          
    155            // not already on network, form/join a network
    156            else
    157            {
    158              zcl_SetEZModeState( EZMODE_STATE_JOINER );
    159            }
    160          
    161            // start a total timeout for EZ_Mode (will cancel if not finished in this time)
    162            zcl_EZModeStartTimer( *zclEZModeRegisterData.pTaskID,
    163                               zclEZModeRegisterData.timeoutEvt, EZMODE_TIME );
    164          }
    165          
    166          /*********************************************************************
    167           * @fn      zcl_EZModeAction
    168           *
    169           * @brief   Called when the application needs to inform EZ-Mode of some action
    170           *          (now on the network, identify mode query, etc...)
    171           *
    172           * @param   action - which action has taken place
    173           *          pData  - the data unique to the action
    174           *
    175           * @return  none
    176           */
    177          void zcl_EZModeAction(zclEzMode_Action_t action, zclEZMode_ActionData_t *pData)
    178          {
    179            ZDO_MatchDescRsp_t *pMatchDescRsp;
    180            zAddrType_t dstAddr;
    181          
    182            // not in the EZ-Mode state machine, so do nothing
    183            if( zclEZModeState == EZMODE_STATE_READY )
    184              return;
    185          
    186            switch ( action )
    187            {
    188              case EZMODE_ACTION_PROCESS:
    189                zcl_ProcessEZMode();  // process next state
    190              break;
    191          
    192              case EZMODE_ACTION_NETWORK_STARTED:
    193                // once on the network, time to go on to the identify state
    194                if( zclEZModeState == EZMODE_STATE_JOINER )
    195                {
    196                  // set local permit joining on locally only for joiners (openers turn it on across the network)
    197                  zcl_EZModePermitJoiningRequest( *zclEZModeRegisterData.pTaskID, NULL,
    198                                                 (byte)(EZMODE_TIME / 1000) ); // in seconds
    199                  zcl_SetEZModeState( EZMODE_STATE_IDENTIFYING );
    200                }
    201              break;
    202          
    203              // received identify query
    204              case EZMODE_ACTION_IDENTIFY_QUERY:
    205          
    206                // targets just go to autoclose once they have been identified
    207                if ( !zclEZModeInvokeData.initiator )
    208                {
    209                  zcl_SetEZModeState( EZMODE_STATE_AUTOCLOSE );
    210                }
    211              break;
    212          
    213              // received identify query response
    214              case EZMODE_ACTION_IDENTIFY_QUERY_RSP:
    215          
    216                if ( pData->pIdentifyQueryRsp->srcAddr->addr.shortAddr
    217                    != zcl_EZModeGetNwkAddr() )
    218                {
    219                  // remember the node we found via identify query
    220                  zclEZModeQueryRspNwkAddr = pData->pIdentifyQueryRsp->srcAddr->addr.shortAddr;
    221                  zclEZModeQueryRspEP = pData->pIdentifyQueryRsp->srcAddr->endPoint;
    222          
    223                  // initiate match descriptor request on the remote node
    224                  dstAddr.addrMode = Addr16Bit;
    225                  dstAddr.addr.shortAddr = zclEZModeQueryRspNwkAddr;
    226                  zcl_EZModeSendMatchDescReq( *zclEZModeRegisterData.pTaskID,
    227                                    &dstAddr,
    228                                    zclEZModeQueryRspNwkAddr,
    229                                    zclEZModeInvokeData.numActiveOutClusters,
    230                                    zclEZModeInvokeData.pActiveOutClusterIDs,
    231                                    zclEZModeInvokeData.numActiveInClusters,
    232                                    zclEZModeInvokeData.pActiveInClusterIDs );
    233                  zcl_SetEZModeState( EZMODE_STATE_WAITING_MATCHDESCRSP );
    234                }
    235              break;
    236          
    237              // received match descriptor response, see if active clusters match
    238              case EZMODE_ACTION_MATCH_DESC_RSP:
    239          
    240                pMatchDescRsp = pData->pMatchDescRsp;
    241                if ( ( pMatchDescRsp && pMatchDescRsp->status == ZSuccess ) && ( pMatchDescRsp->cnt>0 ) )
    242                {
    243                  zclEZModeMatched = TRUE;
    244          
    245                  dstAddr.addr.shortAddr = zclEZModeQueryRspNwkAddr;
    246                  dstAddr.addrMode = Addr16Bit;
    247          
    248                  // bind each matching input cluster
    249                  if ( zclEZModeInvokeData.numActiveInClusters )
    250                  {
    251                    zcl_EZModeBindAddEntry( zclEZModeInvokeData.endpoint, &dstAddr, zclEZModeQueryRspEP,
    252                                  zclEZModeInvokeData.numActiveInClusters, zclEZModeInvokeData.pActiveInClusterIDs );
    253                  }
    254          
    255                  // bind each matching output cluster
    256                  if ( zclEZModeInvokeData.numActiveOutClusters )
    257                  {
    258                    zcl_EZModeBindAddEntry( zclEZModeInvokeData.endpoint, &dstAddr, zclEZModeQueryRspEP,
    259                                  zclEZModeInvokeData.numActiveOutClusters, zclEZModeInvokeData.pActiveOutClusterIDs );
    260                  }
    261                }
    262          
    263                // time to close (wait a bit before finishing, to allow for multiple initiators)
    264                zcl_SetEZModeState( EZMODE_STATE_AUTOCLOSE );
    265              break;
    266          
    267              // timed out of EZ-Mode
    268              case EZMODE_ACTION_TIMED_OUT:
    269                // timed out
    270                if(zclEZModeState != EZMODE_STATE_READY)
    271                {
    272                  zcl_SetEZModeError( EZMODE_ERR_TIMEDOUT );
    273                  zcl_SetEZModeState( EZMODE_STATE_FINISH );
    274                }
    275              break;
    276            }   // switch ( action )
    277          
    278          }
    279          
    280          /*********************************************************************
    281           * LOCAL VARIABLES
    282           */
    283          
    284          
    285          /*********************************************************************
    286           * LOCAL FUNCTIONS
    287           */
    288          
    289          /*********************************************************************
    290           * @fn      zcl_SetEZModeState
    291           *
    292           * @brief   Move on to new state after a short wait.
    293           *
    294           * @param   none
    295           *
    296           * @return  none
    297           */
    298          static void zcl_SetEZModeState( zlcEZMode_State_t newState )
    299          {
    300            zclEZModeState = newState;
    301            zcl_EZModeStartTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, 5 );
    302          }
    303          
    304          /*********************************************************************
    305           * @fn      zclSampleSw_SetEZModeError
    306           *
    307           * @brief   Called to set error code that will be reported on finish. Starts as EZMODE_ERR_SUCCESS.
    308           *
    309           * @param   none
    310           *
    311           * @return  none
    312           */
    313          static void zcl_SetEZModeError( uint8 errorCode )
    314          {
    315            zclEZModeErr = errorCode;
    316          }
    317          
    318          /*********************************************************************
    319           * @fn      zcl_ProcessEZMode
    320           *
    321           * @brief   Called when EZ-Mode changes state. See EZMODE_STATE_xxxx in zcl_ezmode.h
    322           *
    323           * @param   none
    324           *
    325           * @return  status
    326           */
    327          static void zcl_ProcessEZMode( void )
    328          {
    329            zAddrType_t dstAddr;
    330            afAddrType_t afDstAddr;
    331            zclEZMode_CBData_t cbData;
    332          
    333            dstAddr.addr.shortAddr = 0xfffc;        // all routers (for PermitJoin) devices
    334            dstAddr.addrMode = AddrBroadcast;
    335          
    336            afDstAddr.addr.shortAddr = 0xffff;      // all devices (for IdentifyQuery)
    337            afDstAddr.addrMode = afAddrBroadcast;
    338            afDstAddr.endPoint = 0xff;
    339          
    340            switch(zclEZModeState)
    341            {
    342              // openers will broadcast permit joining
    343              case EZMODE_STATE_OPENER:
    344                zclEZModeOpener = 1;
    345          
    346                // enable joining both locally and over-the-air
    347                zcl_EZModePermitJoiningRequest( *zclEZModeRegisterData.pTaskID, &dstAddr,
    348                                               (byte)(EZMODE_TIME / 1000) );
    349          
    350                // then go to identifying state
    351                zcl_SetEZModeState(EZMODE_STATE_IDENTIFYING);
    352              break;
    353          
    354              // joiners will try to join the network, and if success will go to identifying state
    355              case EZMODE_STATE_JOINER:
    356                zclEZModeOpener = 0;
    357                zcl_EZModeStartDevice(*zclEZModeRegisterData.pTaskID, 0);   // see ZDO_STATE_CHANGE in zclSampleSw_event_loop()
    358              break;
    359          
    360              // go into identify state
    361              case EZMODE_STATE_IDENTIFYING:
    362          
    363                // tell app to go into identify mode
    364                if ( zclEZModeRegisterData.pfnNotifyCB )
    365                {
    366                  (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, NULL );
    367                }
    368          
    369                // initiators start looking for other nodes in identify mode
    370                if ( zclEZModeInvokeData.initiator )
    371                {
    372                  zcl_SetEZModeState ( EZMODE_STATE_WAITING_IDENTIFYQUERYRSP );
    373                }
    374              break;
    375          
    376              // timeout out with no query response, send another
    377              case EZMODE_STATE_WAITING_IDENTIFYQUERYRSP:
    378                // ZStatus_t zclGeneral_SendIdentifyQuery( uint8 srcEP, afAddrType_t *dstAddr, uint8 disableDefaultRsp, uint8 seqNum );
    379                // NOTE: Ensure that Identify Cluster is enabled to use this function for EZ-Mode
    380                zclGeneral_SendIdentifyQuery( zclEZModeInvokeData.endpoint, &afDstAddr, TRUE, (*zclEZModeRegisterData.pZclSeqNum)++ );
    381          
    382                // wait some time before sending out the next IdentifyQuery, will stop when we get a response
    383                zcl_EZModeStartTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, EZMODE_IDQUERYTIME );
    384                break;
    385          
    386              // waiting for simple descriptor response
    387              case EZMODE_STATE_WAITING_MATCHDESCRSP:
    388              break;
    389          
    390              // if waiting on autoclose, then we're done. Go to success.
    391              case EZMODE_STATE_AUTOCLOSE:
    392          
    393                // special case: if 2 initators, we only fail if no match from either side
    394                if( zclEZModeInvokeData.initiator && !zclEZModeMatched )
    395                {
    396                  zcl_SetEZModeError ( EZMODE_ERR_NOMATCH );
    397                }
    398          
    399                // if user specified callback, call on AutoClose
    400                if ( zclEZModeRegisterData.pfnNotifyCB )
    401                {
    402                  cbData.sAutoClose.err = zclEZModeErr;
    403                  (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, &cbData );
    404                }
    405          
    406                // no longer will timeout, since cannot fail
    407                zcl_EZModeStopTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.timeoutEvt );
    408          
    409                // wait a little to turn off identify mode, to give time for the other side to discover
    410                // in case of complex devices (both target/initiator)
    411                zcl_EZModeStartTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, EZMODE_AUTOCLOSETIME );
    412          
    413                // go to finish state after autoclose. Don't use zcl_SetEZModeState() because we don't want it to happen immediately
    414                zclEZModeState = EZMODE_STATE_FINISH;
    415              break;
    416          
    417              case EZMODE_STATE_FINISH:
    418          
    419                // no longer will timeout, since we're done
    420                zcl_EZModeStopTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.timeoutEvt );
    421          
    422                // if we opened the network, close it now (turn off joining)
    423                if ( zclEZModeOpener )
    424                {
    425                  zcl_EZModePermitJoiningRequest( *zclEZModeRegisterData.pTaskID, &dstAddr, 0 );
    426                }
    427          
    428                // if user callback, inform them of the finish, which will also turn off identify
    429                if ( zclEZModeRegisterData.pfnNotifyCB )
    430                {
    431                  cbData.sFinish.err = zclEZModeErr;
    432                  cbData.sFinish.ep = zclEZModeQueryRspEP;
    433                  cbData.sFinish.nwkaddr = zclEZModeQueryRspNwkAddr;
    434                  (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, &cbData );
    435                }
    436          
    437                // done, back to ready state
    438                zclEZModeState = EZMODE_STATE_READY;
    439              break;
    440            }
    441          }
    442          
    443          #if !defined ( ZCL_STANDALONE )
    444          /*********************************************************************
    445           * @fn      zcl_EZModeSendMatchDescReq
    446           *
    447           * @brief   Call to send a ZDP Match Descriptor Request
    448           *
    449           * @param   srcID - source task ID sending,
    450           *          for ZCL_STANDALONE, use source endpoint
    451           * @param   dstAddr - destination address
    452           * @param   nwkAddr - network address of interest
    453           * @param   NumInClusters - number of input clusters
    454           * @param   InClusterList - input cluster ID list
    455           * @param   NumOutClusters - number of output clusters
    456           * @param   OutClusterList - output cluster ID list
    457           *
    458           * @return  afStatus_t
    459           */
    460          afStatus_t zcl_EZModeSendMatchDescReq( uint8 srcID,
    461                                                 zAddrType_t *dstAddr,
    462                                                 uint16 nwkAddr,
    463                                                 uint8  NumInClusters,
    464                                                 uint16 *InClusterList,
    465                                                 uint8  NumOutClusters,
    466                                                 uint16 *OutClusterList )
    467          {
    468            (void)srcID;
    469            return ZDP_MatchDescReq( dstAddr,
    470                                     nwkAddr,
    471                                     ZCL_HA_PROFILE_ID,
    472                                     NumInClusters,
    473                                     InClusterList,
    474                                     NumOutClusters,
    475                                     OutClusterList,
    476                                     FALSE );
    477          }
    478          
    479          /*********************************************************************
    480           * @fn      zcl_EZModeStartTimer
    481           *
    482           * @brief   This function is called to start a timer to expire in n mSecs.
    483           *          When the timer expires, call zcl_EZModeAction().
    484           *
    485           * @param   uint8 taskID - task id to set timer for
    486           * @param   uint16 event_id - event to be notified with
    487           * @param   uint32 timeout_value - in milliseconds.
    488           *
    489           * @return  SUCCESS, or NO_TIMER_AVAIL.
    490           */
    491          afStatus_t zcl_EZModeStartTimer( uint8 task_id, uint16 event_id,
    492                                            uint32 timeout_value )
    493          {
    494            return osal_start_timerEx( task_id, event_id, timeout_value );
    495          }
    496          
    497          /*********************************************************************
    498           * @fn      zcl_EZModeStopTimer
    499           *
    500           * @brief   This function is called to cancel a timer.
    501           *
    502           * @param   uint8 taskID - task id to set timer for
    503           * @param   uint16 event_id - event to be notified with
    504           *
    505           * @return  SUCCESS, or NO_TIMER_AVAIL.
    506           */
    507          afStatus_t zcl_EZModeStopTimer( uint8 task_id, uint16 event_id )
    508          {
    509            return osal_stop_timerEx( task_id, event_id );
    510          }
    511          
    512          /*********************************************************************
    513           * @fn      zcl_EZModePermitJoiningRequest
    514           *
    515           * @brief   Call to set the permit joining for device and network.
    516           *
    517           * @param   srcID - source task ID sending,
    518           *          for ZCL_STANDALONE, use source endpoint
    519           * @param   dstAddr - destination address of the message (short addr only),
    520           *                    NULL to send to local device only.
    521           * @param   duration - Permit duration
    522           *
    523           * @return  none
    524           */
    525          void zcl_EZModePermitJoiningRequest( uint8 srcID, zAddrType_t *dstAddr,
    526                                              uint8 duration )
    527          {
    528            zAddrType_t tmpAddr;
    529          
    530            (void)srcID;
    531          
    532            tmpAddr.addrMode = Addr16Bit;
    533          
    534            if ( dstAddr == NULL )
    535            {
    536              tmpAddr.addr.shortAddr = NLME_GetShortAddr();
    537            }
    538            else
    539            {
    540              tmpAddr.addr.shortAddr = dstAddr->addr.shortAddr;
    541            }
    542          
    543            // Trust Center significance is always true
    544            ZDP_MgmtPermitJoinReq( &tmpAddr, duration, TRUE, FALSE );
    545          }
    546          
    547          /*********************************************************************
    548           * @fn      zcl_EZModeStartDevice
    549           *
    550           * @brief   Call to start a device joining.
    551           *
    552           * @param   srcID - source task ID sending,
    553           *          for ZCL_STANDALONE, use source endpoint
    554           * @param   startDelay - timeDelay to start device (in milliseconds)
    555           *
    556           * @return      none
    557           */
    558          void zcl_EZModeStartDevice( uint8 srcID, uint16 startDelay )
    559          {
    560            (void)srcID;
    561            ZDOInitDevice( startDelay );
    562          }
    563          
    564          /*********************************************************************
    565           * @fn      zcl_EZModeBindAddEntry()
    566           *
    567           * @brief   This function is used to Add an entry to the binding table
    568           *
    569           * @param   srcEpInt - source endpoint
    570           * @param   dstAddr - destination Address
    571           * @param   dstEpInt - destination endpoint
    572           * @param   numClusterIds - number of cluster Ids in the list
    573           * @param   clusterIds - pointer to the Object ID list
    574           *
    575           * @return  pointer to binding table entry, NULL if not added
    576           */
    577          void zcl_EZModeBindAddEntry( uint8 srcEpInt,
    578                                       zAddrType_t *dstAddr, uint8 dstEpInt,
    579                                       uint8 numClusterIds, uint16 *clusterIds )
    580          {
    581            if ( pbindAddEntry )
    582            {
    583              if ( pbindAddEntry( srcEpInt, dstAddr, dstEpInt, numClusterIds, clusterIds ) )
    584              {
    585                ZDApp_NVUpdate();
    586              }
    587            }
    588          }
    589          
    590          /*********************************************************************
    591           * @fn      zcl_EZModeGetNwkAddr()
    592           *
    593           * @brief   This function is used to Add an entry to the binding table
    594           *
    595           *   NOTE: Do not call this function outside of zcl_ezmode.c.
    596           *   NOTE2:  For ZCL_STANDALONE, this function needs to be implemented
    597           *           elsewhere.
    598           *
    599           * @param       none
    600           *
    601           * @return  16 bit network address
    602           */
    603          uint16 zcl_EZModeGetNwkAddr( void )
    604          {
    605            return ( NLME_GetShortAddr() );
    606          }
    607          #endif // !ZCL_STANDALONE
    608          
    609          #endif // ZCL_EZMODE


 

 


Errors: none
Warnings: none
